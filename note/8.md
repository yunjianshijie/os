# 开始问题  
1. 通过计算1到100的累加和，学习一种重要的数据结构——栈，了解
处理器为访问栈提供了怎样的支持；
    >栈 由段寄存器SS指向（一个段的首地址）和栈指针SP的寻址是在SS:SP

2. 总结INTEL8086处理器的寻址方式；
    >
3. 学习几个新的处理器指令，它们是or、and、push和pop；
    >or 或操作 and &操作 push 压栈 pop 出栈
4. 学习在Bochs中调试程序时查看栈的方法。
    >

##  显示字符串

本次采用的是循环指令loop。loop指令的工作又依赖于寄存器`CX`，所以，源程序第20行，用于在编译阶段计算一个循环次数，该循环次数等于字符串的长度（字符个数）。

循环体是从第22行开始的，将数据段中的逻辑地址为DS：SI的地方取得的第一个地址，取得第一个字符，将七传送到逻辑地址ES:DI后者指向显示器的缓冲区。

紧接着 
```
    inc di 
    mov byte [es:di],0x07 ;显示属性
    inc di
```
在将di加1

## 累计的各个数位的分解

### 8.5.1 栈和栈段的初始化

和前面不同，各个数位保存在栈上（以前保存在数据段上）

和代码段、数据段和附加段一样，栈也被定义成一个内存段，叫栈段(Stack Segment)，由段寄存器SS指向。

定义栈需要两个连续的步骤，即初始化段寄存器SS和栈指针SP的内
容。
```
    xor cx,cx              ;设置堆栈段的段基地址
    mov ss,cx
    mov sp,cx
```
线程的内存布局
![8.2](8.2.png)

    总的内存容量是1MB,物理地址范围是0x00000到0xfffff假定数据段的长度是64KB（实际上它的长度无关紧要），占据了物理地址0x07C00～0x17BFF，对应的逻辑地址范围是0x07C0:0x0000～0x07C0:0xFFFF；代码段和栈段是同一个段，占据着物理地址0x00000～0x0FFFF，对应的逻辑地址范围是0x0000:0x0000～0x0000:0xFFFF。



### 分解各个数位并压栈

分解数位还是的靠做除法，
把除数写进bx
```
  mov bx,10
  xor cx,cx
```
以往分解寄存器AX中的数时，固定是分解5次，得到5个数位。但这也存在一个缺点，如果AX中的数很小时，在屏幕上显示的数左边都是“0”，这当然是很别扭的。为此，本章的源程序做了改善，每次除法结束后，都做一次判断，如果商为0的话，分解过程可以提前结束。

将DX清零，并和AX一起形成32位的被除数。
```
 xor dx,dx ;清零dx
 div bx ;
 or dl,0x30 ;直接加上ascll码
```
#### or and
与xor一样，or也是逻辑运算指令。不同之处在于，or执行的是逻辑“或”。数字逻辑中的“或”用于表示两个命题并列的情况。（只要有1就是1）
就有加上的因为ascll码0x30是3*16-->48前4位都是0所有直接或得到ascll码

处理器内部，or指令的目的操作数可以是8位或者16位的通用寄存器，或者包含8/16位实际操作数的内存单元，源操作数可以是与目的操作数数据宽度相同的通用寄存器、内存单元或者立即数。

or指令不允许目的操作数和源操作数都是内存单元的情况出现。

or指令对标志寄存器的影响是：OF和CF位被清零，SF、ZF、PF位的状态依计算结果而定，AF位的状态未定义。
与or对应的是and（&）

#### push 压栈

push指令的作用是将寄存器DX的内容压入栈中.push(只接受16位的操作数)
```
 push dx
```
后面其他的处理可以，但是在8086中，只能压入16
非法操作
``` 
push al
push byte [label_a]
```
同时执行push操作时，会将寄存器的sp做减去操作数的字长（（以字节为单位的长度，在16位处理器上是2），然后把压入栈的数据存放到逻辑地址ss:sp .（和其他段的读写一样，把栈段寄存器SS的内容左移4位，加上栈指针寄存器SP提供的偏移地址）


#### 为什么重叠区不会影响！

    图8-3所示，代码段和栈段是同一个段，所以段寄存器CS和SS的内容都是0x0000。而且，栈指针寄存器SP的内容在源程序第42行被置为0。所以，当push指令第一次执行时，SP的内容减2，即0x0000-0x0002=0xFFFE，借位被忽略。于是，被压入栈的数据，在内存中的位置实际上是0x0000:0xFFFE。push指令的操作数是字，而且INTEL处理器是使用低端字节序的，故低字节在低地址部分，高字节在高地址部分，正好占据了栈段的最高两个字节位置。

![第一次执行压栈操作时的内存状态](8.3.png)

#### pop
    处理器将栈段寄存器SS的内容左移4位，再加上栈指针寄存器SP的内容，形成20位的物理地址访问内存，取得所需的数据。





## 栈！

push执行后，压入栈中仅仅是该寄存器或者内存单元里的数值，与该寄存器或者内存单元不再相关。
push cs（将代码寄存器内容压栈）
pop ds  (弹出数据段的寄存器ds)
所以是栈和数据段一样的

保持栈的平衡意思是将入栈出栈平衡

## 8086处理器的寻址方式

多数指令操作的是数值，比如mov ，add 这种   

寻址方式：寄存器寻址，立即寻址


```
add bx,0xf000
mov dx,label_a
```


d