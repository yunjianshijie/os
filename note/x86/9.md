第9章　硬盘和显卡的访问与控制
352
1. 模拟操作系统加载应用程序的过程，演示段的重定位方法，最终使你彻底理解8086处理器的分段内存管理机制；

2. 学习x86处理器过程调用的程序执行机制；

3. 以读硬盘扇区和控制屏幕光标为实例，了解x86处理器访问外围硬件设备的方法；

4. 总结jmp和call指令的全部格式；

5. 认识更多的x86处理器指令，如in、out、shl、shr、rol、ror、jmp、call、ret等

定义段：
section 段名称
segment 段名称

### 关于段 
1. 编译器不关心这是什么段，需要你自己定义（你觉得是啥段就是啥段），自己取名字

2. NASM对段的数量没有限制。一些大的程序，可能拥有不止一个代码段和数据段。

3. 指定段的对齐方式，应该使用“align=”子句，并指定一个具体的对齐。比如说，“align=16”就表示段是16字节对齐的，“align=32”就表示段是32字节对齐的


## 加载器  用户程序 协议
比如说，在用户程序内部的某个固定位置，包含一些基本的结构信息，每个用户程序都必须把自己的情况放在这里，而加载器也固定在这个位置读取。
经验表明，把这个约定的地点放在用户程序的开头

![加载器与用户程序之间协议部分](9.1.png)

头部需要在源程序以一个段的形式出现。这就是代码清单9-2的第7行：
```
SECTION header vstart=0                     ;定义用户程序头部段 
```
因为是头部所以说是第一个被第一的设定段

要包含头部起码包含
1. 用户程序的尺寸
```
  program_length  dd program_end          ;程序总长度[0x00]
```
长度取自程序的标号`program_end`，在编译阶段，编译器将该标号所代表的汇编地址填写在这里。

这个标号在最后的`trail`段，这个段没有`vstart`子句所以偏移量是按程序首地址算的，数值上等于整个程序的长度。

>双字在内存中的存放也是按低端序的。如图9-6所示，低字保存在低地址，高字保存在高地址。同时，每个字又按低端字节序，低字节在低地址，高字节在高地址。

![双字数据在内存中的布局](9.2.png)

2. 应用程序的入口点(段地址和偏移地址)
加载器不知道程序的分段情况，只用知道怎么入口。必须在头部给出第一条指令的段地址和偏移地址



3. 



