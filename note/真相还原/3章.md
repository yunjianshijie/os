# 完善MBR(主引导记录)

## 地址、section、vstart 

### 地址
距第一个符号的距离便是它们在程序中的地址。

上述的偏移量本质上就是地址，每个变量的地址是前一个变量的地址+前一个变量的内存空间大小

第 1 行和第 4 行的 mov 的机器码中第 1 字节都是 B8，其原因是寻址方式都是立即数。

cwd（将word转化成double word）

大概意思是 section 用 vstart=来修饰后，可以被赋予一个虚拟起始地址 virtual start address(强调了这个是虚拟的地址)

code.节名.start== 节在整个程序的地址，相当于与文件开头的偏移量

## ret call 

>ret 作用 ：从栈顶获取2个字节的字数，放进ip寄存器里面\
retf作用： 从栈顶获取4个字节，放进cs:ip里面

（用栈顶元素改变cpu执行流，正确与否由程序员）

call指令和ret是一对配合\
call far 和retf是一对配合
### call 实模式

8086 处理器有两个指令能实现改变程序的流程 一个是jmp，一个是call。区别是jmp属于不回头的执行新代码，适用于`交接`，比如说BIOS交给MBR。call属于执行万一段分支之后再回来的情况，他回来要用retf或者ret配合。
call实现一个函数的调用，有四种方式。
(第一二种，近调用，34远调用)

---

#### 16 位实模式相对近调用
1. 相对近调用概念
 
- 什么是`近`？  目标函数和当前代码在同一段内，不用切换段（基地址），只用给段内偏移量   
- 什么是`相对`？  在同一个代码段中，所以只要给出目标函数的相对地址即可。

2. 格式：
```
call near 立即数地址
```
- 操作数是立即数(near可以省略)。这里的立即数可以是被调用的函数名，也可以是标号，立即数。反正最后编译器都会换成实际的数字。

- 最后的操作数是call指令对于目标的偏移量（就是说是地址差）。

3. call的编译器转换地址

- 比如说指令`call near 0x1234` 他的机械码是e8llhh。
由于x86是小端，所以说ll是低位，hh是高位。实际跳转目标为hhll。 
- 
4. 相对近调用的优势
    
- 由于操作数是相对地址，因此代码位置的改变不会影响指令的执行，提高了代码的可移植性。
- 相对地址的计算由编译器完成，简化了开发人员的工作。
5. 代码
``` assembly
call near near_proc
jmp $
addr dd 4
near_proc：
	mov ax， 0x1234
	ret
```
`call near near_proc`的操作码是`e8 06 00` 

- `e8`是`call near`的操作码。
- `06 00`操作数, 表示目标函数 `near_proc` 的地址相对于当前 `call` 指令地址的偏移量为6。
    - 当前指令地址是0x900
    - 目标函数是0x909
    - 操作数是06，是因为指令大小为3

#### 16 位实模式间接绝对近调用
1. 概念
- 


