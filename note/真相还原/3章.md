# 完善MBR(主引导记录)

## 地址、section、vstart 

### 地址
距第一个符号的距离便是它们在程序中的地址。

上述的偏移量本质上就是地址，每个变量的地址是前一个变量的地址+前一个变量的内存空间大小

第 1 行和第 4 行的 mov 的机器码中第 1 字节都是 B8，其原因是寻址方式都是立即数。

cwd（将word转化成double word）

大概意思是 section 用 vstart=来修饰后，可以被赋予一个虚拟起始地址 virtual start address(强调了这个是虚拟的地址)

code.节名.start== 节在整个程序的地址，相当于与文件开头的偏移量

## ret call 

>ret 作用 ：从栈顶获取2个字节的字数，放进ip寄存器里面\
retf作用： 从栈顶获取4个字节，放进cs:ip里面

（用栈顶元素改变cpu执行流，正确与否由程序员）

call指令和ret是一对配合\
call far 和retf是一对配合
### call 实模式

8086 处理器有两个指令能实现改变程序的流程 一个是jmp，一个是call。区别是jmp属于不回头的执行新代码，适用于`交接`，比如说BIOS交给MBR。call属于执行万一段分支之后再回来的情况，他回来要用retf或者ret配合。
call实现一个函数的调用，有四种方式。
(第一二种，近调用，34远调用)

---

#### 16 位实模式相对近调用
1. 相对近调用概念
 
- 什么是`近`？  目标函数和当前代码在同一段内，不用切换段（基地址），只用给段内偏移量   
- 什么是`相对`？  在同一个代码段中，所以只要给出目标函数的相对地址即可。

2. 格式：
```
call near 立即数地址
```
- 操作数是立即数(near可以省略)。这里的立即数可以是被调用的函数名，也可以是标号，立即数。反正最后编译器都会换成实际的数字。

- 最后的操作数是call指令对于目标的偏移量（就是说是地址差）。

3. call的编译器转换地址

- 比如说指令`call near 0x1234` 他的机械码是e8llhh。
由于x86是小端，所以说ll是低位，hh是高位。实际跳转目标为hhll。 
- 
4. 相对近调用的优势
    
- 由于操作数是相对地址，因此代码位置的改变不会影响指令的执行，提高了代码的可移植性。
- 相对地址的计算由编译器完成，简化了开发人员的工作。
5. 代码
``` assembly
call near near_proc
jmp $
addr dd 4
near_proc：
	mov ax， 0x1234
	ret
```
`call near near_proc`的操作码是`e8 06 00` 

- `e8`是`call near`的操作码。
- `06 00`操作数, 表示目标函数 `near_proc` 的地址相对于当前 `call` 指令地址的偏移量为6。
    - 当前指令地址是0x900
    - 目标函数是0x909
    - 操作数是06，是因为指令大小为3

#### 16 位实模式间接绝对近调用
1. 概念
- `绝对`是指 目标函数地址是绝对地址。
- `间接`  值 相对的地址要么在内存中，要么寄存器中，反正不是立即数
- `近`，其实就是替换ip的地址（跟上一个一样）
2. 指令形式
```assembly
call ax        ; call 寄存器地址 
call [0x1234]  ; call 内存寻址
```
- 内存寻址的操作码是ff16，机器码是 `ff16+16位内存地址` 。
- 如果是寄存器寻址，机器码与寄存器相关 call ax是ffd0 cx是ddd1 。
3. 代码
``` assembly
section call_test vstart=0x900 
mov word [addr], near_proc 
call [addr]  ;3 
mov ax, near_proc ;4
call ax  ;5
jmp $ 
addr dd 4 
near_proc: 
mov ax, 0x1234 
ret
```
- 第三行是用内存在调用的。
    - 第七行是定义了 addr 是4个字节的变量(dd)。
    - near_proc是函数名,用word告诉编译器读两个字节
- 第五行使用寄存器调用的。

> 注意，寄存器寻址中，若在寄存器名称前添加数据类型伪指令，编译器会报警告：“warning： register size specification ignored”。警告信息字面上的意思是寄存器大小被忽略。只是提示警告，不影响编译，编译的机器码依然是正确的。

#### 16 位实模式直接绝对远调用

1. 概念
- `远` 跨段（使用cs:ip寄存器）
- 
2. 格式
``` assembly
call far 段基地址（立即数）：段内偏移地址（立即数）
```
 - 对于绝对远调度far可以不加
3. 代码
``` assembly
section call_test vstart=0x900 
call 0：far_proc 
jmp $ 
far_proc：
mov ax， 0x1234 
retf 
```

![16 位直接绝对远调用指令与机器码对照表](../poto/3-3.png)




