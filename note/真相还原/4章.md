# 4 保护模式入门
## 保护模式
### 为什么要有保护模式
- 安全原因
    - 实模式下操作系统和用户程序属于同一特权极
    - 用户程序引用的地址都指向真是物理地址
    - 用户程序可以自由的修改段地址，可以自由改
- 使用原因
    -  访问64kb就要切换地址
    - 一次只能运行一个程序
    - 内存最大只能用1mb，太小了

因此程序内部的地址（虚拟地址）需要被转化为物理地址后再去访问，程序对此一无所知。顺便说一句，地址转换是由处理器和操作系统共同协作完成的，处理器在硬件上提供地址转换部件，操作系统提供转换过程中所需要的页表。

### 实模式不是 32 位 CPU，变成了 16 位

- 实模式时，指的是 32 位的 CPU 运行在 16 位模式下的状态，不是 CPU 变身成的16位。

### 保护模式之寄存器扩展

- 32位寄存器在原本寄存器的情况

![保护模式下的被扩展成32位寄存器](../poto/4/4-132位寄存器.png)

- 左边已经标注名字的寄存器有通用寄存器组，名字前统一加了字符 E 表示扩展

- 全局描述符表
    - 为了更加安全，怎么也得多添加点约束条件才靠谱。这些“约束条件”便是对内存段的描述信息。一个寄存器放不下，所以得放到一个表里面
    - 表里面有`段描述符`，大小为64字节，用来描述各个内存段的起始地址、大小、权限等信息
    - 所以说现在段里面保存的不是段基址，叫`段选择子`。
    - 问题
        - 段描述符是在内存中，访问内存cpu来说属于比较慢的动作。
        - 段描述符一个数据要分三个地方存。
- 段描述符缓冲寄存器
    - 以后每次访问相同的段时，就直接读取该段寄存器对应的段描述符缓冲寄存器
    - 为了解决每次从全局描述表里面拿东西速度太慢了
    - 既然是缓存，就一定要有个失效时间。段描述符缓冲寄存器的失效时间是多少？

![段描述符缓冲寄存器结构](../poto/4/4-2-段描述符缓冲结构.png)

>80286 虽然有了保护模式，但其依然是 16 位的 CPU，其通用寄存器还是 16 位宽。但其与 8086 不同的是其地址线由 20 位变为了 24 位，即寻址空间变成了 2 的 24 次方，等于 16MB 大小。

80286 的问题是：单独的一个寄存器无法访问到全部内存空间，也就是若用寄存器存储段内偏移地址，只能访问到 64KB 大小的段。

所以说没啥意义，80386就把地址线改为32位了。

CPU 有三种模式：实模式、虚拟 8086 模式、保护模式。（虚拟 8086 模式是为了向下兼容）


### 保护模式之寻址扩展
- 实模式内存寻址
``` assembly
mov ax,[si] 
mov ax,[di] 
mov ax,[bx] 
mov ax,[bx+si] 
mov ax,[bx+si+0x1234] 
mov ax,[bx+di] 
mov ax,[bx+di+0x1234]
```
>模式下对于内存寻址来说，其中的基址寻址、变址寻址、基址变址寻址
这三种形式中的基址寄存器只能是 bx、bp，变址寄存器只能是 si、di



- 在保护模式中
    
    两种寻址方式不同
    ![alt text](../poto/4/4-3.png)
    在保护模式下，所有 32 位的通用寄存器，变址寄存器也是一样，（不止是bx,bp,si,di）。
    ``` assembly
    mov eax，[eax+edx*8+0x12345678] 
    mov eax，[eax+edx*2+0x8] 
    mov eax，[ecx*4+0x1234] 
    ```
    虽然 esp 无法用作变址寄存器，但其可用于基址寄存器。所以，如下代码是正确的
    ```
    mov eax,[esp]
    mov eax,[esp+2]
    ```
### 保护模式之运行模式反转

g







